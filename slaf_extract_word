import streamlit as st
import docx
import xml.etree.ElementTree as ET
import re

def extract_glossary(docx_file):
    glossary_terms = []
    doc = docx.Document(docx_file)
    
    # Track parsing state
    current_finnish_term = None
    current_swedish_terms = None
    current_description = []
    
    for paragraph in doc.paragraphs:
        text = paragraph.text.strip()
        
        # Check for Finnish term (bold)
        if paragraph.runs and any(run.bold for run in paragraph.runs):
            # If we had a previous incomplete entry, add it
            if current_finnish_term and current_swedish_terms:
                glossary_terms.append((
                    current_finnish_term, 
                    current_swedish_terms, 
                    " ".join(current_description).strip()
                ))
            
            # Reset for new term
            current_finnish_term = text.replace('**', '').strip()
            current_swedish_terms = None
            current_description = []
        
        # Check for Swedish terms (typically italicized)
        elif paragraph.runs and any(run.italic for run in paragraph.runs):
            # Extract Swedish terms, removing italics markers
            current_swedish_terms = text.replace('*', '').replace(';', ';').strip()
        
        # Capture description paragraphs
        elif current_finnish_term and current_swedish_terms:
            # Exclude empty strings and very short texts that might be separators
            if text and len(text) > 2:
                current_description.append(text)
    
    # Add the last entry if exists
    if current_finnish_term and current_swedish_terms:
        glossary_terms.append((
            current_finnish_term, 
            current_swedish_terms, 
            " ".join(current_description).strip()
        ))
    
    return glossary_terms

# Function to create TBX XML structure
def create_tbx(glossary_terms):
    martif = ET.Element("martif")
    text = ET.SubElement(martif, "text")
    body = ET.SubElement(text, "body")
    
    for finnish_term, swedish_terms, description in glossary_terms:
        term_entry = ET.SubElement(body, "termEntry")
        
        # Finnish term
        finnish_langset = ET.SubElement(term_entry, "langSet", {"xml:lang": "fi"})
        finnish_term_elem = ET.SubElement(finnish_langset, "term")
        finnish_term_elem.text = finnish_term
        
        # Swedish term(s)
        swedish_langset = ET.SubElement(term_entry, "langSet", {"xml:lang": "sv"})
        swedish_term_elem = ET.SubElement(swedish_langset, "term")
        swedish_term_elem.text = swedish_terms
        
        # Description
        if description:
            descrip_elem = ET.SubElement(term_entry, "descrip")
            descrip_elem.text = description
    
    return ET.ElementTree(martif)

# Streamlit interface
st.title("Word Glossary to TBX Converter")

# Upload Word document
uploaded_file = st.file_uploader("Upload a Word document", type="docx")

if uploaded_file is not None:
    # Extract glossary terms
    glossary_terms = extract_glossary(uploaded_file)
    
    # Display extracted terms
    st.write("Extracted Terms:")
    for term in glossary_terms:
        st.write(f"Finnish: {term[0]}")
        st.write(f"Swedish: {term[1]}")
        st.write(f"Description: {term[2]}")
        st.write("---")
    
    # Create TBX structure
    tbx_tree = create_tbx(glossary_terms)
    
    # Save TBX to file and allow download
    output_file = "glossary_output.tbx"
    tbx_tree.write(output_file, encoding="utf-8", xml_declaration=True)
    
    st.success("TBX file created successfully!")
    with open(output_file, "rb") as file:
        st.download_button(label="Download TBX file", data=file, file_name=output_file, mime="application/xml")